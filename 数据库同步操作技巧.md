models.py 数据库同步操作技巧
## 认识一个目录 ##
-  目录名：migrations
- 作用：用来存放通过makemigrations命令生成的数据库脚本，不熟悉情况下，里面生成的脚本不要轻易修改。**app目录下必须要有migrations的目录且该目录下必须要有__init__.py才能正常的使用数据库同步功能。**
## 认识一张数据表（django_migrations） ##
数据库脚本的使用记录
- 表中字段：
	
	app:app名字
	name:脚本的文件名称
	applied:脚本执行时间
- 数据库相关的命令
>
	flush:清空数据库 - 恢复数据库到最初状态
	makemigrations 生产数据库同步的脚本
	migrate 同步数据库
	showmigrations 查看生产的数据库脚本
	sqlflush 查看生产清空数据库的脚本
	sqlmigrate  查看数据库同步的sql语句

- 终极大招
	>
	在开发的过程中，数据库同步误操作之后，难免会遇到后面不同步成功的情况，解决这个问题的方法，以是去分析生产的数据库脚本和django_migrations中的同步记录是否匹配，
	**另外一个简单粗暴的方法就是把migrations目录下的脚本(出__init__.py)之外全部删除，再把数据库删除掉之后创建一个新的数据库，数据库同步操作在重新做一遍。**

# ORM常用操作
##增加
create和save方法
实例：

	增加一条作者记录
		>>> AuthorDetail.objects.create(sex=False,email='zhang@qq.com',address='北京市XXX',birthday='1989-01-02',author_id=2)
		(0.001) INSERT INTO `hello_authordetail` (`sex`, `email`, `address`, `birthday`, `author_id`) VALUES (0, 'zhang@qq.com',
		 '北京市XXX', '1989-01-02', 2); args=[False, 'zhang@qq.com', '北京市XXX', '1989-01-02', 2]
		(0.001) SELECT VERSION(); args=None
		(0.001) SELECT `hello_author`.`id`, `hello_author`.`name` FROM `hello_author` WHERE `hello_author`.`id` = 2; args=(2,)
		<AuthorDetail: 胡大海>

	增加一条出版社记录
		>>> pub = Publisher()
		>>> pub.name="新华出版社"
		>>> pub.address = '北京昌平沙河'
		>>> pub.city = '北京'
		>>> pub.state_province='北京'
		>>> pub.country='中国'
		>>> pub.website='http://www.google.com'
		>>> pub.save()
		(0.000) INSERT INTO `hello_publisher` (`name`, `address`, `city`, `state_province`, `country`, `website`) VALUES ('新华
		出版社', '北京昌平沙河', '北京', '北京', '中国', 'http://www.google.com'); args=['新华出版社', '北京昌平沙河', '北京', '
		北京', '中国', 'http://www.google.com']
	增加一条书籍记录

	主外键用对象的方式插入数据
		>>> Book.objects.create(title='python实战',publisher=pub,publication_date='2009-5-6')
		(0.000) INSERT INTO `hello_book` (`title`, `publisher_id`, `publication_date`) VALUES ('python实战', 2, '2009-05-06'); a
		rgs=['python实战', 2, '2009-05-06']
		<Book: python实战>

		>>> book.authors.add(author)
		(0.001) SELECT `hello_book_authors`.`author_id` FROM `hello_book_authors` WHERE (`hello_book_authors`.`book_id` = 3 AND
		`hello_book_authors`.`author_id` IN (2)); args=(3, 2)
		(0.001) INSERT INTO `hello_book_authors` (`book_id`, `author_id`) VALUES (3, 2); args=(3, 2)

objects:model默认管理器。create是这个管理器里面的方法

插入主外键关系的时候，可以用对象的方式，也可以直接关联id的方式。
插入多对多关系的时候要分布操作。

save这个方法是Model对象的方法

##修改
update和save方法  update是QuerySet对象的方法
实例
	
	修改id为1的作者的名字为叶良辰，性别为女
	author = Author.objects.get(id=1) 
	author.name='叶良辰' 
	author.save()
	修改名为"电子工业出版社"的出版社网站为 http://www.google.com,城市为成都
	>>> Publisher.objects.filter(id=2).update(city='成都',website='http://www.google.com')
	
##查询（惰性机制） 
实例：
	查询所有出版社信息
	Publisher.objects.all() 在没有调用查询结果的时候，语句不执行
所谓惰性机制：

	publish.object.all()只是返回了一个QuerySet（查询结果集对象），并不会马上执行sql，而是当调用QuerySet的时候才执行。
##删除
	delete方法   也是QuerySet对象的方法
实例：
	1.删除id为1的书籍信息
	Book.objects.filter(id=1).delete()
	2. 删除出版社城市为成都的记录
	Publiser.objects.filter(city='成都').delete() 

注意
django中删除默认是级联删除的。

有没有提供批量增加数据的方法。
[https://docs.djangoproject.com/en/1.11/ref/models/querysets/](https://docs.djangoproject.com/en/1.11/ref/models/querysets/)

#QuerySet常用的API（惰性的）
django.db.models.query.QuerySet

QuerySet特点
	
	可迭代的
	可切片

##查询相关的API
1. **get(**kwarhs)**: 返回与所给的筛选条件相匹配的对象，返回结果有且只有一个。如果符合筛选条件的对象超过一个，就会抛出MultipleObjectsReturned异常，如果没有找到符合筛选条件的对象，就会抛出DoesNotExit异常。
** 返回的是一个Model对象。很容易发生异常，只有有且只有一个的时候才会正确执行**
2. **all() **查询所有结果
3.  ** filter**(**kwargs) 它包含了所有给的选条件相匹配的对象
4. exclude(*kwargs) 它包含那些与所给筛选条件不匹配的对象。
5. order_by(*fields) 对查询结果排序
6. ** reverse() **对查询结果反向排序
7. **distinct() **从返回结果中剔除严重重复的记录
8. **values(*fields)** 返回一个ValuesQuerySet---一个特殊的QuerySet，运行后得到的并不是一系列model的实例化对象，而是一个可迭代的字典序列
9. values_list(*feild) 他与values（）非常相似，只不过后者返回的结果是字典序列，而values_lsit() 返回的结果是元组序列。
10. **count（）** 返回数据库中匹配查询（QuerySet）的对象数量
11. first() 范湖第一条记录 等价于[:1][0]
12. last() 返回最后一条记录 等价于 [::-1][0]
13. exists() 如果QuerySet包含有数据，就返回True，否则返回False

更多详见
[https://docs.djangoproject.com/en/1.11/ref/models/querysets/](https://docs.djangoproject.com/en/1.11/ref/models/querysets/)

##来一些实例：
1. 查询id为1的书籍信息，并只显示书籍名称和出版日期
	Book.objects.filter(id=1).values('title','publication_date')
2. 查询所有的出版社信息，并按id降序排序，并尝试使用reverse方法进行反向排序
	Publisher.objects.all().order_by('-id')
	Publisher.objects.all().order_by('id').reverse()
3. 查询出版社所在的城市信息，城市信息不要重复
	Publisher.objects.filter(id=1).values('title','publication_date')
4. 查询城市是北京的出版社，尝试使用exclude方法
5. 查询男作者的数量 

# 多表关联查询
实例：

	1. 查询作者的所有完整信息
		AuthorDetail.objects.values('sex','email','address','author__name')
	2. 查询<21成为撩妹高手>这本书的作者姓名，还有出版社的名字
		 Book.objects.filter(title='21天成为撩妹高手').values('publisher__name')
	3. 查询胡大海谢了一些什么书
		 Book.objects.filter(author__name='胡大海').values('title')
	4. 查询广东人民出版社都出版了一些什么书籍
		 Book.objects.filter(publisher__name='广东人民出版社').values('title')
	5. 查询人民出版社都有那些作者出过书
		 Book.objects.filter(publisher__name='人民出版社').values('authors__name')
##多表查询技巧
__:两个下划线可以生成连接查询，查询关联的字段信息
_set:提供了对象访问相关联数据的方法，但是这种只能是相关类访问定义了关系的类（主键类访问外键类） 

## 聚集查询和分组查询
实例：
1. 给Book模型增加一个价格字段
2. 查询广东人民出版社出了多少本书
	>>> Publisher.objects.filter(name='广东人民出版社').count() （QuerySet的方法）
		聚合函数
		 Publisher.objects.filter(name='广东人民出版社').aggregate(Count('name'))
		起别名：
		Publisher.objects.filter(name='广东人民出版社').aggregate(mycount=Count('name'))
3. 查询胡大海出的书总价格是多少
 	Book.objects.filter(authors__name='叶良辰').aggregate(Sum('price'))
4. 查询各个作者出的书的总价是多少
	>>> Book.objects.values('authors__name').annotate(Sum('price'))
5. 查询各个出版社的书价是多少
	>>> Book.objects.values('publisher__name').annotate(Mix('price'))

1. annotate(*args**kwargs)： 可以为QuerySet中每个对象添加注解。可以通过计算查询结果中每个对象所关联的对象集合，从而得出总计值(也可以是平均值或总和，等等)，**用户分组查询**
2. aggregate(*args**kwargs):通过对QuerySet进行计算，返回一个聚合值的字典。aggregate()中每个参数都指定一个包含在字典中的返回值。**用户聚合插叙**

聚合函数(Aggregation Functions)
	
	所在位置：django.db.models

	1. Avg	返回所给字段的平均值
	2. Count 根据所给的关联字段返回被关联model的数量
	3. Max 返回所给字段的最大值
	4. Min 返回所给字段的最小值
	5. Sum 计算总和

##使用原生sql
注意使用原生sql的方式主要目的是解决一些复杂的sql不能用ORM方式写出的问题。

1. extra：结果集修改器--一种提供额外查询参数的机制
2. raw 执行原生sql并返回模型实例
3. 直接执行自定义sql（这种方式完全不依赖与model，前面两种还是要依赖于model）

##具体实例

###使用extra
1. Book.objects.filter(publisher__name='广东人民出版社').extra(where=['price>50'])
2. Book.objects.filter(publisher__name='广东人民出版社',price_gt=50)
3. Book.objects.extra(select={'count':select count(*) from hello_book})

###使用raw
1. Book.objects.raw('select * from hello_book')  返回一个QuerySet对象  惰性执行

###自定义sql
from django.db import connection
# 获得一个游标(cursor)对象
cursor = connection.cursor()
# 插入操作
cursor.execute("insert hello_author(name) values('郭敬明')")
# 更新操作
cursor.execute("update hello_author set name='韩寒' where name = '郭敬明'")
# 删除操作
cursor.execute("delete from hello_author where name = '韩寒'")
# 查询操作
cursor.execute("select * from hello_author")
#返回结果行
raw = cursor.fetchone()
cursor.fetchall()
		

	