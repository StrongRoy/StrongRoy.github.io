#数据库的配置

django默认支持sqlite mysql oracle postgresql数据库，
像db2和 sqlserver之类的数据库需要第三方的支持

具体详见：
[https://docs.djangoproject.com/en/1.11/ref/databases/](https://docs.djangoproject.com/en/1.11/ref/databases/ "django数据库文档")


Using a 3rd-party database backend¶

In addition to the officially supported databases, there are backends provided by 3rd parties that allow you to use other databases with Django:

SAP SQL Anywhere
IBM DB2
Microsoft SQL Server
Firebird
ODBC
The Django versions and ORM features supported by these unofficial backends vary considerably. Queries regarding the specific capabilities of these unofficial backends, along with any support queries, should be directed to the support channels provided by each 3rd party project.

# django常用数据库介绍
-  sqlite:
>
	django 默认使用sqlite的数据库，默认自带sqlite的数据库驱动，
引擎名称
	django.db.backends.sqlite3

 - mysql
>
引擎名称：
	django.db.backends.mysql

## mysql数据库的驱动程序
1. mysql 驱动程序
>
 (mysql-python 只支持2 不支持3) [https://pypi.python.org/pypi/MySQL-python/1.2.5](https://pypi.python.org/pypi/MySQL-python/1.2.5 "MySQLdb"
 (mysql-python 的一个分支 支持3)[https://pypi.python.org/pypi/mysqlclient](https://pypi.python.org/pypi/mysqlclient "mysqlclient")

2. MySQL官方驱动

	[https://dev.mysql.com/downloads.connector/python](https://dev.mysql.com/downloads.connector/python "Connector/Python: ")

3. 安装简单 

	Pymysql (纯python的mysql驱动程序)
	[https://pypi.python.org/pypi/MyMysql](https://pypi.python.org/pypi/MyMysql)
# 演示pymysql的使用。
	1. 安装pymysql
	2. 修改配置文件
			DATABASES = {
			    'default': {
			        'ENGINE': 'django.db.backends.mysql',
			        'NAME': 'hello_django_db',
			        'USER':'root',
			        'PASSWORD': 'wanglq1299',
			        'HOST': '127.0.0.1',
			        'POST':'3306',
			    }
			}
	3. 在工程目录的__init_.py增加代码
		import pymysql
		pymysql.install_as_MySQLdb()

# orm机制
![](https://i.imgur.com/XbeUcfA.png)

## 定义：
	对象关系映射（object relatioal Mapping 简称ORM）,用于实现
	面向对象编程语言里不同类型系统的数据之间的转换。换句话说，
	就是**用于面向对象的方式操作数据库的创建表、增加、修改，删除、查询等操作。**

## 演示 查看ORM生成的sql语句
1. 使用QuerySet中的query属性
2. 配置日志系统，将sql显示到控制台

		LOGGING={
			'version':1,
			'disable_exitsting_loggers':False,
			'handlers':{
				'console':{
					'level':'DEBUG',
					'class': 'logging.StreamHandler',
				},
			},
			'loggers':{
				'django.db.backends':{
					'handlers':['console'],
					'propagate':'True',
					'level':'DEBUG',
				},
			}
		}
django日志的详细见:
	[https://docs.djangoproject.com/en/1.11/topics/logging/](https://docs.djangoproject.com/en/1.11/topics/logging/)

3.  使用一些开发工具 django_debug_toolbar
4. ORM优缺点：

	优点：

		1. ORM使得我们的通过数据库交互变得简单易行，并且完全不用考虑该死的SQL语句。快速开发 由此而来

		2. 可以避免一些新手程序员写sql语句来带的性能和效率问题。
	缺点：

		1. 性能有所牺牲，不过现在的各种ORM框架都在尝试使用各种方法减轻这个问题（lazyLoad，Cache）效果还是很显著的。
		2. 对于个别复杂的查询，orm任仍然力不从心，为解决这个问题，ORM框架一般也会提供直接写原生sql的方式。

##models.py 模型类的定义
创建数据模型

示例：

	我们来嘉定下面的这些概念、字段和关系

作者模型:
	
	一个作者的姓名。

作者性情模型：
	
	把作者的详情放到详情表，包括性别、email地址和出生日期、作者详情模型和作者模型之间是一对一的关系(OneToOneField)

出版商模型：

	出版商有名称、地址、所在城市、省、国家、网站。

书籍模型：

	书籍有书名和出版日期。一本书可能有多个作者、一个作者也可以写多本书、所以作者和数据的关系是多
	对多的关系。一本书只应该有一个出版商出版
所以出版商和数据 是一对多的关联关系[ont -to-many] 也被称为外键[ForeignKey]

代码：
	
	from django.db import models

	# Create your models here.
	
	class Publisher(models.Model):
	    name=models.CharField(max_length=30)
	    address = models.CharField(max_length=50)
	    city = models.CharField(max_length=60)
	    state_province = models.CharField(max_length=30)
	    country = models.CharField(max_length=50)
	    website = models.URLField()
	
	
	class Author(models.Model):
	    name = models.CharField(max_length=30)
	
	
	class AuthorDetail(models.Model):
	    sex = models.BooleanField(max_length=1,choices=((0,'男'),(1,'女'),))
	    email = models.EmailField()
	    address = models.CharField(max_length=50)
	    birthday = models.DateField()
	    author = models.OneToOneField(Author)
	
	
	class Book(models.Model):
	    title = models.CharField(max_length=100)
	    authors = models.ManyToManyField(Author)
	    publisher = models.ForeignKey(Publisher)
	    publication_date = models.DateField()
###一起来看看上面的代码：

1. **每个数模型都是django.db.models.Model的子类**，它的父类Model包含了所哟䌘的数据库
交互的方法，并提供了一个简洁漂亮的定义数据库字段的语法。
2. **每个模型相当于单个数据库表**(这个规则的类外情况是多对多关系，多对多关系的时候
会生成一张关系表)、每个属性也是这个表中的一个字段。属性名就是字段名，他的类型（例如CharField）
相当于数据库的字段类型（例如 varchar）。大家可以留意其他的类型都和数据库的什么字段类型对应。
3. 模型之间的三种关系：
	- . 一对一(OneToOneField)  
	- . 一 对多（ForeignKey)
	- . 多对多(MonyToManyField)

4. 模型的常用字段类型
 	>
	BooteanField	  
	CharField	  
	DateField	  
	DateTimeField	  
	DecimalField （精确）小数字段	  
	EmailField	  
	FileField  文件字段(保存和处理上传文件)	  
	FloatField	  
	ImgeField	  
	IntegerField 图片字段(保存和处理上传图片)	  
	IPAdderssField IP字段	  
	SmallInterField  小整数字段	  
	TextField 文本字段	  
	URLField 网页地址字段	  

5. 模型常用的字段选项
	1. null (null=True|False)
	数据库字段的设置是否可以为空 数据库进行验证
	2. blank (blank=True|False)
	字段是否为空 django会进行校验 （表单进行验证）
	3. choices 轻量级的配置字段可选属性定义
	4. default 字段的默认值
	5. help_text 字段文字帮助
	6. primary_key (=True|False) 一般情况不需要定义是否主键
	如果没有显示指明主键的话，django会自动增加一个默认的主键
	 id = models.AutoField(primary_key=True)
	7. unique
	是否唯一 对数据表而言
	8. verbose_name 字段的详细名称 如果不定制该属性 默认使用
	字段的属性名称

字段类型和字段选项的设置更多详见
[https://docs.djangoproject.com/en/1.11/ref/models/fields](https://docs.djangoproject.com/en/1.11/ref/models/fields)

##定义数据模型的扩展属性
    通过内部类Mate给数据模型类增加扩展属性：
class Meta:	  
	verbose_name = '名称'	  
	verbose_name_plural = '名称复数形式'	  
	ordering = ['排序字段']	  
还有很多扩展 详见
[https://docs.djangoproject.com/en/1.11/ref/models/options/](https://docs.djangoproject.com/en/1.11/ref/models/options/)	  
思考题：

	通过查阅上面的文档，了解设置哪个属性可以给数据模型对应的数据库
	表进行命令
#定义模型的方法
	定义模型方法和普通python类方法没有太大差别，定义模型方法可以将
	当前对应的数据，组装成具体的业务逻辑。

示例：
	
	定义__unicode__()让对象有默认的名字
注意：
	python2里面用__unicode__()，python3里面用__str__()
	def __str__(self):
		return self.name

#设置显示别名：
## 数据显示名称
	def __str__(self):
		return self.name
##字段显示别名方式
	name = models.CharField(max_length=30,verbose_name='名称')
	name = models.CharField('名称',max_length=30)

    




	
